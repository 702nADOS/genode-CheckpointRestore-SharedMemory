/*
 * \brief  Intercepting (TODO insert name) session
 * \author
 * \date   yyyy-mm-dd
 */

// TODO insert specific session name
#ifndef _RTCR_TEMPLATE_SESSION_H_
#define _RTCR_TEMPLATE_SESSION_H_

/* Genode includes */
// TODO include correct session connection
// #include <template_session/connection.h>
#include <root/component.h>
#include <util/list.h>

// TODO rename ALL class names and ctor/dtor names and debug variables
namespace Rtcr {
	struct Template_rpc_object_info;
	struct Template_session_info;
	class Template_session_component;
	class Template_root;

	constexpr bool template_verbose_debug = false;
	constexpr bool template_root_verbose_debug = false;
}


/**
 * List element for monitoring Rpc objects created by the virtual session object
 */
struct Rtcr::Template_rpc_object_info : Genode::List<Template_rpc_object_info>::Element
{
	/**
	 * Reference to session object; encapsulates capability and object's state
	 */
	Template_rpc_object_component &rpc_object;

	Template_rpc_object_info(Template_rpc_object_component &rpc_object);

	/**
	 * Find list element by Capability of the virtual session
	 *
	 * \param cap Capability to search for
	 *
	 * \return List element with the specified Capability
	 */
	// TODO adjust intercepted session capability
	Template_rpc_object_info *find_by_cap(Genode::Capability<Genode::Intercepted_session> cap);
};

/**
 * List element for monitoring session objects.
 * Each new connection from client to server is monitored here.
 */
struct Rtcr::Template_session_info : Genode::List<Template_session_info>::Element
{
	/**
	 * Reference to the session object; encapsulates capability and object's state
	 */
	Template_session_component &session;
	/**
	 * Arguments provided for creating the session object
	 */
	const char *args;

	Template_session_info(Template_session_component &comp, const char* args);

	Template_session_info *find_by_ptr(Template_session_component *ptr);
};

/**
 * Virtual session object to intercept Rpc object creation and
 * state modifications of the wrapped, parent session object
 */
 // TODO adjust template variable of Rpc_object
class Rtcr::Template_session_component : public Genode::Rpc_object<Genode::Template_session>
{
private:
	/**
	 * Enable log output for debugging
	 */
	static constexpr bool verbose_debug = template_verbose_debug;
	/**
	 * Allocator for Rpc objects created by this session and also for monitoring structures
	 */
	Genode::Allocator             &_md_alloc;
	/**
	 * Entrypoint for managing created Rpc objects
	 */
	Genode::Entrypoint            &_ep;
	/**
	 * Parent's session connection which is used by the intercepted methods
	 */
	// TODO use correct connection to parent's session and rename ALL occurences of this variable
	Genode::Template_connection    _parent_template;

	/**
	 * Parent's session state
	 */
	struct State_info
	{
		// TODO insert member attributes which describe the state of the session object
		Genode::Dataspace_capability cap     {}; // Calls standard ctor
		unsigned                     num     {};
		bool                         boolean {};
	} _parent_state;
    /**
     * Lock for infos list
     */ 
    // TODO create as many locks as there are lists and protect the access to each list with a corresponding lock
    Genode::Lock                            _infos_lock;
    /**
     * List for monitoring Rpc object
     */ 
    // TODO create as many lists as needed
    Genode::List<Template_rpc_object_info> _rpc_object_infos;

public:
	Template_session_component(Genode::Env &env, Genode::Allocator &md_alloc, Genode::Entrypoint &ep, const char *args);
    // TODO destroy all allocated objects
	~Template_session_component();
    
    // TODO create getter/setter methods for them
    Genode::List<Template_rpc_object_info> &rpc_object_infos() { return _rpc_object_infos; }
    void rpc_object_infos(Genode::List<Template_rpc_object_info> &infos) { _rpc_object_infos = infos; }

	// TODO adjust comment
	/************************************
	 ** Template session Rpc interface **
	 ************************************/

	/*
	 * TODO Implement session's methods
	 * you want to create monitoring list elements, whenever an Rpc object is created by a method
	 * also, you want to delete monitoring list elements, whenever an Rpc object is deleted by a method
	 * Compare other intercepted sessions (e.g. rm_session.h)
	 */

	Genode::size_t method_with_result(String const &arg1, String const &arg2) override;
	void method_without_result(String const &arg1, String const &arg2) override;

};

/**
 * Virtual Root session object to intercept session object creation
 * This enables the Rtcr component to monitor capabilities created for session objects
 */
class Rtcr::Template_root : public Genode::Root_component<Template_session_component>
{
private:
	/**
	 * Enable log output for debugging
	 */
	static constexpr bool verbose_debug = template_root_verbose_debug;

	/**
	 * Environment of Rtcr; is forwarded to a created session object
	 */
	Genode::Env                    &_env;
	/**
	 * Allocator for session objects and monitoring list elements
	 */
	Genode::Allocator              &_md_alloc;
	/**
	 * Entrypoint for managing session objects
	 */
	Genode::Entrypoint             &_ep;
	/**
	 * Lock for infos list
	 */
	Genode::Lock                    _infos_lock;
	/**
	 * List for monitoring session objects
	 */
	Genode::List<Template_session_info>  _session_infos;

protected:
	/**
	 * Create session object and its monitoring list element
	 */
	Template_session_component *_create_session(const char *args);
	/**
	 * Destroy session object and its monitoring list element
	 */
	void _destroy_session(Template_session_component *session);

public:
	Template_root(Genode::Env &env, Genode::Allocator &md_alloc, Genode::Entrypoint &session_ep);
    ~Template_root();
    
    // TODO create getter/setter
    Genode::List<Template_session_info> &session_infos() { return _session_infos;  }
    void session_infos(Genode::List<Template_session_info> &infos) { _session_infos = infos; }
};

// TODO adjust comment
#endif /* _RTCR_TEMPLATE_SESSION_H_ */
